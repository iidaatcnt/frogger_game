<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Éï„É≠„ÉÉ„Ç¨„Éº</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .game-container {
            text-align: center;
        }
        
        canvas {
            border: 2px solid #0f0;
            background: #111;
            image-rendering: pixelated;
        }
        
        .info {
            margin: 10px 0;
            font-size: 18px;
        }
        
        .controls {
            margin-top: 15px;
            font-size: 14px;
            color: #ff0;
        }
        
        .sound-note {
            margin-top: 5px;
            font-size: 12px;
            color: #aaa;
        }
        
        .game-over {
            color: #f00;
            font-size: 24px;
            font-weight: bold;
        }
        
        .demo-mode {
            color: #ff0;
            font-size: 20px;
            font-weight: bold;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üê∏ FROGGER üê∏</h1>
        <div class="info">
            <span>„Çπ„Ç≥„Ç¢: <span id="score">0</span></span>
            <span style="margin-left: 30px;">„É©„Ç§„Éï: <span id="lives">3</span></span>
        </div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="controls">
            Áü¢Âç∞„Ç≠„Éº „Åæ„Åü„ÅØ WASD „Åß„Ç´„Ç®„É´„ÇíÊìç‰Ωú
        </div>
        <div class="sound-note">
            üîä ÂäπÊûúÈü≥„ÅÇ„ÇäÔºà„Éñ„É©„Ç¶„Ç∂„ÅßÈü≥Â£∞„ÅåÊúâÂäπ„Å´„Å™„Å£„Å¶„ÅÑ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„ÅôÔºâ
        </div>
        <div id="gameOverText" class="game-over" style="display: none;">
            GAME OVER - R„Ç≠„Éº„Åß„É™„Çπ„Çø„Éº„Éà
        </div>
        <div id="demoText" class="demo-mode" style="display: none;">
            üéÆ DEMO MODE - ‰Ωï„Åã„Ç≠„Éº„ÇíÊäº„Åó„Å¶„Éó„É¨„Ç§ÈñãÂßã üéÆ
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // „Ç≤„Éº„É†Áä∂ÊÖã
        let gameState = {
            score: 0,
            lives: 3,
            gameOver: false,
            level: 1,
            isDemo: false,
            lastUserInput: Date.now(),
            demoMoveTimer: 0,
            demoTarget: { x: 380, y: 50 }
        };
        
        // ÂäπÊûúÈü≥„Ç∑„Çπ„ÉÜ„É†
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playJumpSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        function playScoreSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
            oscillator.frequency.setValueAtTime(500, audioContext.currentTime + 0.1);
            oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.2);
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.3);
            
            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime + 0.3);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }
        
        function playDeathSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.5);
            
            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }
        
        function playGameOverSound() {
            const oscillator1 = audioContext.createOscillator();
            const oscillator2 = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator1.connect(gainNode);
            oscillator2.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator1.frequency.setValueAtTime(300, audioContext.currentTime);
            oscillator1.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 1);
            
            oscillator2.frequency.setValueAtTime(200, audioContext.currentTime);
            oscillator2.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 1);
            
            gainNode.gain.setValueAtTime(0.6, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
            
            oscillator1.start(audioContext.currentTime);
            oscillator2.start(audioContext.currentTime);
            oscillator1.stop(audioContext.currentTime + 1);
            oscillator2.stop(audioContext.currentTime + 1);
        }
        
        // „Ç´„Ç®„É´
        const frog = {
            x: 380,
            y: 550,
            width: 40,
            height: 40,
            startX: 380,
            startY: 550,
            isJumping: false,
            jumpProgress: 0,
            jumpStartX: 0,
            jumpStartY: 0,
            jumpEndX: 0,
            jumpEndY: 0,
            jumpDuration: 200 // „Éü„É™Áßí
        };
        
        // Ëªä„Å®‰∏∏Â§™„ÅÆÈÖçÂàó
        let cars = [];
        let logs = [];
        
        // „Ç≤„Éº„É†„Ç®„É™„Ç¢„ÅÆË®≠ÂÆö
        const ROAD_START = 300;
        const ROAD_END = 500;
        const WATER_START = 100;
        const WATER_END = 250;
        const GOAL_Y = 50;
        
        // ÂàùÊúüÂåñ
        function init() {
            createObstacles();
            gameLoop();
        }
        
        // ÈöúÂÆ≥Áâ©„Çí‰ΩúÊàê
        function createObstacles() {
            cars = [];
            logs = [];
            
            // Ëªä„Çí‰ΩúÊàêÔºàÈÅìË∑Ø„Ç®„É™„Ç¢Ôºâ
            for (let lane = 0; lane < 4; lane++) {
                const y = ROAD_START + lane * 50;
                const direction = lane % 2 === 0 ? 1 : -1;
                const speed = 2 + Math.random() * 2;
                
                for (let i = 0; i < 3; i++) {
                    cars.push({
                        x: direction > 0 ? -100 - i * 200 : canvas.width + i * 200,
                        y: y,
                        width: 60,
                        height: 30,
                        speed: speed * direction,
                        color: ['#f00', '#00f', '#ff0', '#f0f'][lane]
                    });
                }
            }
            
            // ‰∏∏Â§™„Çí‰ΩúÊàêÔºàÂ∑ù„Ç®„É™„Ç¢Ôºâ
            for (let lane = 0; lane < 3; lane++) {
                const y = WATER_START + lane * 50;
                const direction = lane % 2 === 0 ? 1 : -1;
                const speed = 1 + Math.random() * 1.5;
                
                for (let i = 0; i < 2; i++) {
                    logs.push({
                        x: direction > 0 ? -150 - i * 300 : canvas.width + i * 300,
                        y: y,
                        width: 120,
                        height: 30,
                        speed: speed * direction
                    });
                }
            }
        }
        
        // ÊèèÁîªÈñ¢Êï∞
        function draw() {
            // ËÉåÊôØ„Çí„ÇØ„É™„Ç¢
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ÈÅìË∑Ø„ÇíÊèèÁîª
            ctx.fillStyle = '#333';
            ctx.fillRect(0, ROAD_START, canvas.width, ROAD_END - ROAD_START);
            
            // Â∑ù„ÇíÊèèÁîª
            ctx.fillStyle = '#006';
            ctx.fillRect(0, WATER_START, canvas.width, WATER_END - WATER_START);
            
            // „Ç¥„Éº„É´„Ç®„É™„Ç¢„ÇíÊèèÁîª
            ctx.fillStyle = '#060';
            ctx.fillRect(0, 0, canvas.width, GOAL_Y);
            
            // ÂÆâÂÖ®Âú∞Â∏Ø„ÇíÊèèÁîª
            ctx.fillStyle = '#040';
            ctx.fillRect(0, GOAL_Y, canvas.width, 50);
            ctx.fillRect(0, 250, canvas.width, 50);
            ctx.fillRect(0, 500, canvas.width, 50);
            
            // Ëªä„ÇíÊèèÁîª
            cars.forEach(car => {
                ctx.fillStyle = car.color;
                ctx.fillRect(car.x, car.y, car.width, car.height);
                // Ëªä„ÅÆ„É©„Ç§„Éà
                ctx.fillStyle = '#fff';
                if (car.speed > 0) {
                    ctx.fillRect(car.x + car.width - 5, car.y + 5, 3, 8);
                    ctx.fillRect(car.x + car.width - 5, car.y + car.height - 13, 3, 8);
                } else {
                    ctx.fillRect(car.x + 2, car.y + 5, 3, 8);
                    ctx.fillRect(car.x + 2, car.y + car.height - 13, 3, 8);
                }
            });
            
            // ‰∏∏Â§™„ÇíÊèèÁîª
            logs.forEach(log => {
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(log.x, log.y, log.width, log.height);
                // ‰∏∏Â§™„ÅÆÊ®°Êßò
                ctx.fillStyle = '#654321';
                for (let i = 0; i < log.width; i += 20) {
                    ctx.fillRect(log.x + i, log.y + 5, 2, log.height - 10);
                }
            });
            
            // „Ç´„Ç®„É´„ÇíÊèèÁîª
            drawFrog();
        }
        
        function drawFrog() {
            let drawX = frog.x;
            let drawY = frog.y;
            let scale = 1;
            
            // „Ç∏„É£„É≥„Éó„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
            if (frog.isJumping) {
                const progress = frog.jumpProgress;
                // ÊîæÁâ©Á∑ö„ÇíÊèè„ÅèÔºà‰∏ä„Å´Ë∑≥„Å≠‰∏ä„Åå„ÇãÔºâ
                const jumpHeight = Math.sin(progress * Math.PI) * 20;
                drawY -= jumpHeight;
                
                // „Ç∏„É£„É≥„Éó‰∏≠„ÅØÂ∞ë„ÅóÂ§ß„Åç„ÅèË¶ã„Åõ„Çã
                scale = 1 + Math.sin(progress * Math.PI) * 0.3;
            }
            
            // „Ç´„Ç®„É´„ÅÆ‰Ωì
            ctx.fillStyle = '#0f0';
            const scaledWidth = frog.width * scale;
            const scaledHeight = frog.height * scale;
            const offsetX = (scaledWidth - frog.width) / 2;
            const offsetY = (scaledHeight - frog.height) / 2;
            
            ctx.fillRect(drawX - offsetX, drawY - offsetY, scaledWidth, scaledHeight);
            
            // „Ç´„Ç®„É´„ÅÆÁõÆ
            ctx.fillStyle = '#000';
            const eyeSize = 6 * scale;
            ctx.fillRect(drawX - offsetX + 8 * scale, drawY - offsetY + 5 * scale, eyeSize, eyeSize);
            ctx.fillRect(drawX - offsetX + 26 * scale, drawY - offsetY + 5 * scale, eyeSize, eyeSize);
            
            // „Ç´„Ç®„É´„ÅÆÂè£
            ctx.fillStyle = '#000';
            ctx.fillRect(drawX - offsetX + 15 * scale, drawY - offsetY + 25 * scale, 10 * scale, 3 * scale);
            
            // „Éá„É¢„É¢„Éº„Éâ‰∏≠„ÅØÂÖâ„ÇãËº™ÈÉ≠„ÇíËøΩÂä†
            if (gameState.isDemo) {
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.3;
                ctx.strokeRect(drawX - offsetX - 2, drawY - offsetY - 2, scaledWidth + 4, scaledHeight + 4);
                ctx.globalAlpha = 1;
            }
            
            // „Ç∏„É£„É≥„Éó‰∏≠„ÅØË∂≥„ÇíÊèèÁîª
            if (frog.isJumping) {
                ctx.fillStyle = '#0a0';
                // Âæå„ÇçË∂≥
                ctx.fillRect(drawX - offsetX - 5, drawY - offsetY + scaledHeight - 10, 8, 15);
                ctx.fillRect(drawX - offsetX + scaledWidth - 3, drawY - offsetY + scaledHeight - 10, 8, 15);
                // ÂâçË∂≥
                ctx.fillRect(drawX - offsetX + 5, drawY - offsetY + 10, 6, 12);
                ctx.fillRect(drawX - offsetX + scaledWidth - 11, drawY - offsetY + 10, 6, 12);
            }
        }
        
        // „Éá„É¢„Éó„É¨„Ç§„ÅÆAIÂà∂Âæ°
        function updateDemoAI() {
            gameState.demoMoveTimer++;
            
            // 45„Éï„É¨„Éº„É†„Åî„Å®„Å´Ë°åÂãï„ÇíÊ±∫ÂÆöÔºàÁ¥Ñ0.75ÁßíÔºâ
            if (gameState.demoMoveTimer < 45 || frog.isJumping) return;
            
            gameState.demoMoveTimer = 0;
            
            const moveDistance = 50;
            
            // ÁèæÂú®„ÅÆ‰ΩçÁΩÆ„Å´Âü∫„Å•„ÅÑ„Å¶„Ç∑„É≥„Éó„É´„Å™Âà§Êñ≠
            // Âü∫Êú¨Êà¶Áï•ÔºöÂâçÈÄ≤„ÇíÂÑ™ÂÖà„Åó„ÄÅÂç±Èô∫„Åå„ÅÇ„Çå„Å∞ÂõûÈÅø
            
            // „Ç¥„Éº„É´„Ç®„É™„Ç¢„Å´Âà∞ÈÅî„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØÂâçÈÄ≤„ÇíË©¶„Åø„Çã
            if (frog.y > GOAL_Y) {
                // ÈÅìË∑Ø„Ç®„É™„Ç¢„Å´„ÅÑ„ÇãÂ†¥Âêà
                if (frog.y >= ROAD_START && frog.y <= ROAD_END) {
                    // Ëªä„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                    let canMoveUp = true;
                    const nextY = frog.y - moveDistance;
                    
                    cars.forEach(car => {
                        // Ê¨°„ÅÆ‰ΩçÁΩÆ„ÅßËªä„Å®Ë°ùÁ™Å„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                        if (Math.abs(car.y - nextY) < 40) {
                            const futureCarX = car.x + car.speed * 10; // Â∞ë„ÅóÂÖà„ÅÆËªä„ÅÆ‰ΩçÁΩÆ„Çí‰∫àÊ∏¨
                            if (Math.abs(futureCarX - frog.x) < 80) {
                                canMoveUp = false;
                            }
                        }
                    });
                    
                    if (canMoveUp) {
                        simulateKeyPress('ArrowUp');
                    } else {
                        // Â∑¶Âè≥„Å´ÈÅø„Åë„Çã
                        const dodgeDirection = Math.random() > 0.5 ? 'ArrowLeft' : 'ArrowRight';
                        if (dodgeDirection === 'ArrowLeft' && frog.x > 50) {
                            simulateKeyPress('ArrowLeft');
                        } else if (dodgeDirection === 'ArrowRight' && frog.x < canvas.width - frog.width - 50) {
                            simulateKeyPress('ArrowRight');
                        }
                    }
                }
                // Ê∞¥„Ç®„É™„Ç¢„Å´„ÅÑ„ÇãÂ†¥Âêà
                else if (frog.y >= WATER_START && frog.y <= WATER_END) {
                    // ÁèæÂú®‰∏∏Â§™„Å´‰πó„Å£„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                    let currentLog = null;
                    logs.forEach(log => {
                        if (frog.x + frog.width > log.x && frog.x < log.x + log.width &&
                            frog.y + frog.height > log.y && frog.y < log.y + log.height) {
                            currentLog = log;
                        }
                    });
                    
                    if (currentLog) {
                        // ‰∏∏Â§™„ÅÆÁ´Ø„Å´Ëøë„Å•„ÅÑ„Åü„Çâ‰∏≠Â§Æ„Å∏ÁßªÂãï
                        const logCenter = currentLog.x + currentLog.width / 2;
                        const frogCenter = frog.x + frog.width / 2;
                        
                        if (frogCenter < logCenter - 20 && frog.x < canvas.width - frog.width - 50) {
                            simulateKeyPress('ArrowRight');
                        } else if (frogCenter > logCenter + 20 && frog.x > 50) {
                            simulateKeyPress('ArrowLeft');
                        } else {
                            // Ê¨°„ÅÆ‰∏∏Â§™„Å∏„Ç∏„É£„É≥„Éó„Åô„Çã„Çø„Ç§„Éü„É≥„Ç∞„ÇíÊé¢„Çã
                            let canJump = false;
                            const nextY = frog.y - moveDistance;
                            
                            logs.forEach(log => {
                                if (Math.abs(log.y - nextY) < 30) {
                                    const futureLogX = log.x + log.speed * 15;
                                    if (Math.abs(futureLogX + log.width/2 - frogCenter) < 60) {
                                        canJump = true;
                                    }
                                }
                            });
                            
                            if (canJump || nextY < WATER_START) {
                                simulateKeyPress('ArrowUp');
                            }
                        }
                    } else {
                        // ‰∏∏Â§™„Å´‰πó„Å£„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØÁ∑äÊÄ•ÂõûÈÅø
                        simulateKeyPress('ArrowDown');
                    }
                }
                // ÂÆâÂÖ®Âú∞Â∏Ø„Å´„ÅÑ„ÇãÂ†¥Âêà
                else {
                    // ÂçòÁ¥î„Å´ÂâçÈÄ≤
                    simulateKeyPress('ArrowUp');
                }
            }
        }
        
        // „Ç≠„ÉºÂÖ•Âäõ„Çí„Ç∑„Éü„É•„É¨„Éº„Éà
        function simulateKeyPress(key) {
            if (frog.isJumping) return;
            
            const moveDistance = 50;
            let newX = frog.x;
            let newY = frog.y;
            
            switch(key) {
                case 'ArrowUp':
                    if (frog.y > 0) newY = frog.y - moveDistance;
                    break;
                case 'ArrowDown':
                    if (frog.y < canvas.height - frog.height) newY = frog.y + moveDistance;
                    break;
                case 'ArrowLeft':
                    if (frog.x > 0) newX = frog.x - moveDistance;
                    break;
                case 'ArrowRight':
                    if (frog.x < canvas.width - frog.width) newX = frog.x + moveDistance;
                    break;
            }
            
            if (newX !== frog.x || newY !== frog.y) {
                playJumpSound();
                frog.jumpStartX = frog.x;
                frog.jumpStartY = frog.y;
                frog.jumpEndX = newX;
                frog.jumpEndY = newY;
                frog.isJumping = true;
                frog.jumpProgress = 0;
            }
        }
        
        // „Éá„É¢„É¢„Éº„Éâ„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
        function checkDemoMode() {
            if (gameState.gameOver) return;
            
            // 5ÁßíÈñìÊìç‰Ωú„Åå„Å™„Åë„Çå„Å∞„Éá„É¢„É¢„Éº„ÉâÈñãÂßã
            if (!gameState.isDemo && Date.now() - gameState.lastUserInput > 5000) {
                startDemo();
            }
        }
        
        // „Éá„É¢„É¢„Éº„ÉâÈñãÂßã
        function startDemo() {
            gameState.isDemo = true;
            gameState.demoMoveTimer = 0;
            restart(); // „Ç≤„Éº„É†„Çí„É™„Çª„ÉÉ„Éà
            document.getElementById('demoText').style.display = 'block';
        }
        
        // „Éá„É¢„É¢„Éº„ÉâÁµÇ‰∫Ü
        function stopDemo() {
            if (gameState.isDemo) {
                gameState.isDemo = false;
                document.getElementById('demoText').style.display = 'none';
                restart(); // „Ç≤„Éº„É†„Çí„É™„Çª„ÉÉ„Éà
            }
        }
        
        // Êõ¥Êñ∞Èñ¢Êï∞
        function update() {
            if (gameState.gameOver && !gameState.isDemo) return;
            
            // „Éá„É¢„É¢„Éº„Éâ„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
            checkDemoMode();
            
            // „Éá„É¢„É¢„Éº„Éâ‰∏≠„ÅØAI„ÅåÊìç‰Ωú
            if (gameState.isDemo) {
                updateDemoAI();
                
                // „Éá„É¢„É¢„Éº„Éâ‰∏≠„Å´„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº„Åó„Åü„ÇâËá™Âãï„É™„Çπ„Çø„Éº„Éà
                if (gameState.gameOver) {
                    setTimeout(() => {
                        gameState.score = 0;
                        gameState.lives = 3;
                        gameState.gameOver = false;
                        gameState.isDemo = true; // „Éá„É¢„É¢„Éº„Éâ„ÇíÁ∂≠ÊåÅ
                        resetFrog();
                        createObstacles();
                        document.getElementById('gameOverText').style.display = 'none';
                    }, 2000);
                }
            }
            
            // „Ç´„Ç®„É´„ÅÆ„Ç∏„É£„É≥„Éó„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Êõ¥Êñ∞
            if (frog.isJumping) {
                frog.jumpProgress += 1/12; // 60FPS„ÅßÁ¥Ñ200ms
                
                if (frog.jumpProgress >= 1) {
                    frog.jumpProgress = 0;
                    frog.isJumping = false;
                    frog.x = frog.jumpEndX;
                    frog.y = frog.jumpEndY;
                } else {
                    // „Çπ„É†„Éº„Ç∫„Å™ÁßªÂãï
                    const easeProgress = frog.jumpProgress;
                    frog.x = frog.jumpStartX + (frog.jumpEndX - frog.jumpStartX) * easeProgress;
                    frog.y = frog.jumpStartY + (frog.jumpEndY - frog.jumpStartY) * easeProgress;
                }
            }
            
            // Ëªä„ÇíÊõ¥Êñ∞
            cars.forEach(car => {
                car.x += car.speed;
                
                // ÁîªÈù¢Â§ñ„Å´Âá∫„Åü„ÇâÂèçÂØæÂÅ¥„Åã„ÇâÂá∫Áèæ
                if (car.speed > 0 && car.x > canvas.width + 100) {
                    car.x = -car.width - 100;
                } else if (car.speed < 0 && car.x < -car.width - 100) {
                    car.x = canvas.width + 100;
                }
            });
            
            // ‰∏∏Â§™„ÇíÊõ¥Êñ∞
            logs.forEach(log => {
                log.x += log.speed;
                
                // ÁîªÈù¢Â§ñ„Å´Âá∫„Åü„ÇâÂèçÂØæÂÅ¥„Åã„ÇâÂá∫Áèæ
                if (log.speed > 0 && log.x > canvas.width + 150) {
                    log.x = -log.width - 150;
                } else if (log.speed < 0 && log.x < -log.width - 150) {
                    log.x = canvas.width + 150;
                }
            });
            
            // Ë°ùÁ™ÅÂà§ÂÆö
            checkCollisions();
            
            // „Ç¥„Éº„É´Âà§ÂÆö
            if (frog.y <= GOAL_Y) {
                gameState.score += 100;
                playScoreSound(); // ÂæóÁÇπÂäπÊûúÈü≥
                resetFrog();
            }
        }
        
        function checkCollisions() {
            // Ëªä„Å®„ÅÆË°ùÁ™Å
            if (frog.y >= ROAD_START && frog.y <= ROAD_END - frog.height) {
                cars.forEach(car => {
                    if (frog.x < car.x + car.width &&
                        frog.x + frog.width > car.x &&
                        frog.y < car.y + car.height &&
                        frog.y + frog.height > car.y) {
                        loseLife();
                    }
                });
            }
            
            // Ê∞¥„Ç®„É™„Ç¢„Åß„ÅÆ‰∏∏Â§™Âà§ÂÆö
            if (frog.y >= WATER_START && frog.y <= WATER_END - frog.height) {
                let onLog = false;
                logs.forEach(log => {
                    if (frog.x < log.x + log.width &&
                        frog.x + frog.width > log.x &&
                        frog.y < log.y + log.height &&
                        frog.y + frog.height > log.y) {
                        onLog = true;
                        // ‰∏∏Â§™„Å®‰∏ÄÁ∑í„Å´ÁßªÂãï
                        frog.x += log.speed;
                    }
                });
                
                if (!onLog) {
                    loseLife();
                }
            }
            
            // ÁîªÈù¢Â§ñ„ÉÅ„Çß„ÉÉ„ÇØ
            if (frog.x < 0 || frog.x > canvas.width - frog.width) {
                loseLife();
            }
        }
        
        function loseLife() {
            playDeathSound(); // Ê≠ª‰∫°ÂäπÊûúÈü≥
            gameState.lives--;
            if (gameState.lives <= 0) {
                gameOver();
            } else {
                resetFrog();
            }
        }
        
        function resetFrog() {
            frog.x = frog.startX;
            frog.y = frog.startY;
            frog.isJumping = false;
            frog.jumpProgress = 0;
        }
        
        function gameOver() {
            gameState.gameOver = true;
            playGameOverSound(); // „Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÂäπÊûúÈü≥
            document.getElementById('gameOverText').style.display = 'block';
        }
        
        function restart() {
            gameState.score = 0;
            gameState.lives = 3;
            gameState.gameOver = false;
            resetFrog();
            createObstacles();
            document.getElementById('gameOverText').style.display = 'none';
            
            // „Éá„É¢„É¢„Éº„Éâ„Åß„Å™„ÅÑÂ†¥Âêà„ÅØÂÖ•ÂäõÊôÇÈñì„ÇíÊõ¥Êñ∞
            if (!gameState.isDemo) {
                gameState.lastUserInput = Date.now();
            }
        }
        
        // „Ç≠„Éº„Éú„Éº„ÉâÂÖ•Âäõ
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            // „É¶„Éº„Ç∂„ÉºÂÖ•Âäõ„ÇíË®òÈå≤
            gameState.lastUserInput = Date.now();
            
            // „Éá„É¢„É¢„Éº„Éâ‰∏≠„ÅÆÂ†¥Âêà„ÅØÁµÇ‰∫Ü
            if (gameState.isDemo) {
                stopDemo();
                return;
            }
            
            if (gameState.gameOver && e.key.toLowerCase() === 'r') {
                restart();
                return;
            }
            
            if (gameState.gameOver || frog.isJumping) return;
            
            const moveDistance = 50;
            let newX = frog.x;
            let newY = frog.y;
            
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (frog.y > 0) newY = frog.y - moveDistance;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (frog.y < canvas.height - frog.height) newY = frog.y + moveDistance;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (frog.x > 0) newX = frog.x - moveDistance;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (frog.x < canvas.width - frog.width) newX = frog.x + moveDistance;
                    break;
            }
            
            // „Ç∏„É£„É≥„Éó„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÇíÈñãÂßã
            if (newX !== frog.x || newY !== frog.y) {
                playJumpSound(); // „Ç∏„É£„É≥„ÉóÂäπÊûúÈü≥
                frog.jumpStartX = frog.x;
                frog.jumpStartY = frog.y;
                frog.jumpEndX = newX;
                frog.jumpEndY = newY;
                frog.isJumping = true;
                frog.jumpProgress = 0;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // UIÊõ¥Êñ∞
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('lives').textContent = gameState.lives;
        }
        
        // „Ç≤„Éº„É†„É´„Éº„Éó
        function gameLoop() {
            update();
            draw();
            updateUI();
            requestAnimationFrame(gameLoop);
        }
        
        // „Ç≤„Éº„É†ÈñãÂßã
        init();
    </script>
</body>
</html>